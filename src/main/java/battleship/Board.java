package battleship;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Random;

public class Board extends JPanel implements ActionListener {

    private static final int NUMBER_OF_COLUMNS = 10;
    private static final int NUMBER_OF_ROWS = 10;
    private static final int SHIPS_NUMBER = 5;

    private ArrayList<ArrayList<Cell>> mBoardCellArrayList;
    private int mHitCount, mMissCount, mAttemptCount;
    private int mSubmarineCounter = 0, mDestroyerCounter = 0, mBattleshipCounter = 0, mCarrierCounter = 0;

    Board() {
        this.setBackground(Color.WHITE);
        this.setLayout(new GridLayout(NUMBER_OF_ROWS, NUMBER_OF_COLUMNS));
        this.setBorder(BorderFactory.createEmptyBorder(20, 20, 0, 20));

        init();
    }

//    An object of the class Board is the action listener for all the events generated by the Cells.
    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getSource() instanceof Cell) {
            // If the cell is idle (fired upon) return
            if (!((Cell) e.getSource()).isIdle()) return;

            // Fire on the ship and increment the attempt count
            this.mAttemptCount++;
            ((Cell) e.getSource()).fire();

            // Increment hit or miss count depending on the cell occupancy
            if (((Cell) e.getSource()).hasShip()) {
                this.mHitCount++;
                // If all 15 occupied cells have been displayed, the user wins
                if (mHitCount == 15) {
                    JOptionPane.showMessageDialog(this, "All ships Sunk! You have won!");
                    showGrid();
                    return;
                }
                // This switch displays the proper dialog when a ship gets sunk
                switch (((Cell) e.getSource()).getShipType()) {
                    case AIRCRAFT_CARRIER:
                        mCarrierCounter++;
                        if (mCarrierCounter == 5)
                            JOptionPane.showMessageDialog(this, "Aircraft Carrier sunk");
                        break;
                    case BATTLESHIP:
                        mBattleshipCounter++;
                        if (mBattleshipCounter == 4)
                            JOptionPane.showMessageDialog(this, "Battleship sunk");
                        break;
                    case DESTROYER:
                        mDestroyerCounter++;
                        if (mDestroyerCounter == 3)
                            JOptionPane.showMessageDialog(this, "Destroyer sunk");
                        break;
                    case SUBMARINE:
                        mSubmarineCounter++;
                        if (mSubmarineCounter == 2)
                            JOptionPane.showMessageDialog(this, "Submarine sunk");
                        break;
                    case PATROL_BOAT:
                        JOptionPane.showMessageDialog(this, "Patrol boat sunk");
                        break;
                }
            } else this.mMissCount++;
            if (mAttemptCount == Battleship.MAX_ATTEMPTS) {
                JOptionPane.showMessageDialog(this, "Maximum attempts reached. You have lost!");
                showGrid();
            }
        }
    }

//    Resets the game and places all boats at random locations.
    void init() {
        // Create the board array list for the first time
        this.mBoardCellArrayList = new ArrayList<>(NUMBER_OF_ROWS);
        for (int i = 0; i < NUMBER_OF_ROWS; i++) {
            mBoardCellArrayList.add(new ArrayList<>());
        }

        // Initialize board with cells
        reset();
        // Populate the cells with ships
        placeAllShips();
    }

//    Places all 5 kinds of ships on the Board at random locations.
//    Ships cannot overlap and must fit completely onto the board.
//        o Aircraft carrier, length 5
//        o Battleship, length 4
//        o Destroyer, length 3
//        o Submarine, length 2,
//        o Patrol boat, length 1
    void placeAllShips() {
        Random random = new Random(System.currentTimeMillis());
        // Random coordinates for the ship
        int shipX, shipY;
        // True for horizontal, false for vertical
        boolean shipOrientation;
        // True if the ship will fit, false otherwise
        boolean shouldFit;
        Cell workingCell;
        // The type of ship in the cell
        Cell.ShipType shipType;

        // This loop iterates over the ship types placing each ship on the board
        for (int shipSize = 1; shipSize <= SHIPS_NUMBER; shipSize++) {

            // This is simply an initializer to avoid null
            shipType = Cell.ShipType.PATROL_BOAT;

            // Determine the ship type based on the loop counter (size)
            switch (shipSize) {
                case 1:
                    shipType = Cell.ShipType.PATROL_BOAT;
                    break;
                case 2:
                    shipType = Cell.ShipType.SUBMARINE;
                    break;
                case 3:
                    shipType = Cell.ShipType.DESTROYER;
                    break;
                case 4:
                    shipType = Cell.ShipType.BATTLESHIP;
                    break;
                case 5:
                    shipType = Cell.ShipType.AIRCRAFT_CARRIER;
                    break;
                default:
                    break;
            }

            // Generate random coordinates and orientation and check if they will fit, until fitting ones are found
            do {
                shipX = random.nextInt(NUMBER_OF_ROWS);
                shipY = random.nextInt(NUMBER_OF_COLUMNS);
                shipOrientation = random.nextBoolean();
                workingCell = mBoardCellArrayList.get(shipX).get(shipY);

                // Check if the ship size will fit in the empty space with the coordinates and the orientation
                if (shipOrientation)
                    shouldFit = shipX + shipSize < mBoardCellArrayList.size();
                else shouldFit = shipY + shipSize < mBoardCellArrayList.get(shipX).size();

                // Check if the ship cell allocation is all empty and doesn't overlap any existing ships
                if (shouldFit) {
                    if (shipOrientation) {
                        // If horizontal, check the horizontal space from ship start location to end
                        for (int i = 0; i < shipSize; i++) {
                            if (mBoardCellArrayList.get(shipX + i).get(shipY).hasShip()) {
                                shouldFit = false;
                                break;
                            }
                        }
                    } else {
                        // If vertical, check the vertical space from ship start location to end
                        for (int i = 0; i < shipSize; i++) {
                            if (mBoardCellArrayList.get(shipX).get(shipY + i).hasShip()) {
                                shouldFit = false;
                                break;
                            }
                        }
                    }
                }
            } while (!shouldFit);

            // The proper ship coordinates and orientation have been selected for this size
            // Set the cell placing the ship on the grid
            workingCell.setHasShip(true);
            workingCell.setShipType(shipType);

            // The remaining part is for placing ships bigger than 1
            if (shipSize == 1) continue;

            // Fill the remaining cells for the ship size after the initial cell
            for (int k = 0; k < shipSize; k++) {
                if (shipOrientation) {
                    // If horizontal, select the next horizontal cells from starting location to start + size to the ship type
                    workingCell = mBoardCellArrayList.get(shipX + k).get(shipY);
                } else {
                    // If vertical, select the next vertical cells from starting location to start + size to the ship type
                    workingCell = mBoardCellArrayList.get(shipX).get(shipY + k);
                }
                // After selecting the next cell, set its type and occupancy
                workingCell.setHasShip(true);
                workingCell.setShipType(shipType);
            }
        }
    }

    // Displays the content of the Board â€” 0 for an empty cell and 1 when the cell is occupied.
    void printBoard() {
        // This simply iterates over the board array list and prints it row by row
        for (int i = 0; i < NUMBER_OF_ROWS; i++) {
            for (int j = 0; j < NUMBER_OF_COLUMNS; j++) {
                System.out.print(mBoardCellArrayList.get(i).get(j).toString());
            }
            System.out.println();
        }
    }

    // The gets the same string from printBoard() for purposes of displaying in a dialog
    String getBoardArray() {
        String returnString = "";
        for (int i = 0; i < NUMBER_OF_ROWS; i++) {
            returnString = returnString + "Row " + i + ": ";
            for (int j = 0; j < NUMBER_OF_COLUMNS; j++) {
                returnString = returnString + mBoardCellArrayList.get(i).get(j).toString();
            }
            returnString = returnString + "\n";
        }
        return returnString;
    }

    // Displays the total number of attempts, hits and missed since the last reset of the game.
    void printStatistics() {
        System.out.println("Total Attempts: " + this.mAttemptCount);
        System.out.println("Total Hits: " + this.mHitCount);
        System.out.println("Total Misses: " + this.mMissCount);
    }

    // Returns the same string as printStatistics() for purposes of displaying in dialog
    String getStatistics() {
        return "Total Attempts: " + this.mAttemptCount + "\nTotal Hits: " + this.mHitCount
                + "\nTotal Misses: " + this.mMissCount;
    }

    // Reveal all the cells, this is called when the reveal button is cliced
    void showGrid() {
        for (int i = 0; i < NUMBER_OF_ROWS; i++) {
            for (int j = 0; j < NUMBER_OF_COLUMNS; j++) {
                mBoardCellArrayList.get(i).get(j).fire();
            }
        }
    }

    // Ensures that all the cells are idle, unoccupied, and statistics set to zero.
    void reset() {
        this.mAttemptCount = 0;
        this.mMissCount = 0;
        this.mHitCount = 0;
        this.mSubmarineCounter = 0;
        this.mDestroyerCounter = 0;
        this.mBattleshipCounter = 0;
        this.mCarrierCounter = 0;
        for (int i = 0; i < NUMBER_OF_ROWS; i++) {
            for (Cell singleCell : mBoardCellArrayList.get(i)) {
                this.remove(singleCell);
                this.revalidate();
                this.repaint();
            }
            mBoardCellArrayList.get(i).clear();
            for (int j = 0; j < NUMBER_OF_COLUMNS; j++) {
                mBoardCellArrayList.get(i).add(new Cell(this, false));
                this.add(mBoardCellArrayList.get(i).get(j));
            }
        }
    }
}
